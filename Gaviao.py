import streamlit as st
import time
import math
from collections import defaultdict, Counter
from typing import List, Dict, Tuple

-------------------------

Configura√ß√£o da p√°gina

-------------------------

st.set_page_config(page_title="Football Studio AI Predictor v2", layout="wide")

Mapas

emoji_map = {'C': 'üî¥', 'V': 'üîµ', 'E': 'üü°'} color_name = {'C': 'Vermelho', 'V': 'Azul', 'E': 'Empate'}

Estado inicial

if 'history' not in st.session_state: # Mantemos o hist√≥rico com o formato do cassino: √≠ndice 0 = mais recente (√† esquerda) st.session_state.history = []  # cada item: {'result':'C'|'V'|'E', 'timestamp': float}

if 'analysis' not in st.session_state: st.session_state.analysis = {}

-------------------------

Utilit√°rios

-------------------------

def get_color_name(c: str) -> str: return color_name.get(c, '')

def weighted_counts(results: List[str], decay: float = 0.85) -> Dict[str, float]: """Conta resultados com peso exponencial decrescente (mais recente tem peso 1). decay em (0,1): quanto menor, mais forte o peso nas jogadas recentes.""" w = 1.0 counts = {'C': 0.0, 'V': 0.0, 'E': 0.0} for r in results: counts[r] += w w *= decay return counts

def shannon_entropy(results: List[str]) -> float: if not results: return 0.0 total = len(results) freq = Counter(results) ent = 0.0 for _, c in freq.items(): p = c / total ent -= p * math.log2(p) return ent  # em bits

def get_streaks(results: List[str]) -> Tuple[int, Tuple[str, int]]: """Retorna (max_streak, (current_color, current_length)) onde current refere-se ao streak atual (mais recente).""" if not results: return 0, ('', 0) # max streak max_streak = 1 cur = 1 for i in range(1, len(results)): if results[i] == results[i-1]: cur += 1 max_streak = max(max_streak, cur) else: cur = 1 # current streak (come√ßando do √≠ndice 0 - mais recente) cur_color = results[0] cur_len = 1 for i in range(1, len(results)): if results[i] == cur_color: cur_len += 1 else: break return max_streak, (cur_color, cur_len)

def detect_reversal_patterns(results: List[str]) -> List[Dict]: """Detecta padr√µes onde uma sequ√™ncia √© seguida por uma invers√£o/queima deliberada. Ex: C C C V (invers√£o), ou altern√¢ncia que √© intencionalmente quebrada. Retorna lista de ocorr√™ncias com posi√ß√£o relativa (0 = mais recente).""" patterns = [] # analisamos janelas m√≥veis pequenas for width in (4, 5, 6): if len(results) < width + 1: continue for i in range(0, len(results) - width): # janelas com estabilidade seguida de quebra window = results[i:i+width] next_idx = i + width next_val = results[next_idx] if next_idx < len(results) else None # estabilidade: pelo menos 3 dos 1os width serem iguais e o pr√≥ximo ser diferente if len(window) >= 3: most_common = Counter(window).most_common(1)[0] if most_common[1] >= 3 and next_val and next_val != most_common[0]: patterns.append({'type': 'reversal', 'position': i, 'base': most_common[0], 'break': next_val, 'description': f"Revers√£o ap√≥s estabilidade de {most_common[1]}x {get_color_name(most_common[0])} (pos {i})"}) # altern√¢ncia seguida de anomalia if width >= 4: alt = all(window[j] != window[j+1] for j in range(len(window)-1)) if alt and next_val and next_val == window[0]: patterns.append({'type': 'reversal-alt', 'position': i, 'description': f"Altern√¢ncia seguida de repeti√ß√£o at√≠pica (pos {i})"}) return patterns

def detect_anchor_anchors(results: List[str]) -> List[Dict]: """Detecta quando empates (E) aparecem estrategicamente como '√¢ncoras' para resetar padr√µes.""" patt = [] for i, val in enumerate(results): if val == 'E': # verificar vizinhan√ßa: se antes e depois existir mudan√ßa significativa before = results[i+1:i+4]  # mais antigas after = results[0:i]  # mais recentes at√© o empate # se houver altern√¢ncia ou padr√£o antes e depois um reset, considerar √¢ncora if before and after: # padr√£o em before (ex: repeti√ß√£o) e depois diferente if len(set(before)) == 1 and (len(after) == 0 or after[0] != before[0]): patt.append({'type': 'empate-ancora', 'position': i, 'description': f"Empate atuando como √¢ncora em pos {i}"}) return patt

def sliding_window_patterns(results: List[str]) -> List[Dict]: patterns = [] n = len(results) # windows variadas for w in (4, 6, 9): if n < w: continue for i in range(0, n - w + 1): window = results[i:i+w] # 2x2-like em janelas maiores (padr√µes repetidos de pares) for j in range(0, w-3): a, b, c, d = window[j], window[j+1], window[j+2], window[j+3] if a == b and c == d and a != c: patterns.append({'type': '2x2', 'position': i+j, 'description': f"Padr√£o 2x2 detectado pos {i+j}"}) # clusters de empates if window.count('E') >= max(2, w//4): patterns.append({'type': 'empate-cluster', 'position': i, 'description': f"Cluster de empates na janela {i}-{i+w-1}"}) # padr√µes camuflados: pequena repeti√ß√£o dentro de altern√¢ncia # ex: C V C C V C -> detectamos subpadr√µes que se repetem subs = defaultdict(int) for k in range(0, w-2): sub = ''.join(window[k:k+3]) subs[sub] += 1 for sub, cnt in subs.items(): if cnt >= 2: patterns.append({'type': 'camuflado', 'pattern': sub, 'position': i, 'description': f"Padr√£o camuflado '{sub}' repetido na janela {i}-{i+w-1}"}) return patterns

-------------------------

Avalia√ß√£o do n√≠vel de manipula√ß√£o (1-9)

-------------------------

def get_manipulation_level(data: List[Dict]) -> Tuple[int, List[str]]: results = [d['result'] for d in data] if not results: return 1, []

# pesos temporais
weighted = weighted_counts(results, decay=0.85)
total_weight = sum(weighted.values())
# normalizar
w_c = weighted['C'] / total_weight
w_v = weighted['V'] / total_weight
w_e = weighted['E'] / total_weight

ent = shannon_entropy(results)
max_streak, (cur_color, cur_len) = get_streaks(results)

manipulation_signals = []
score = 0.0

# sinal 1: empates elevados nos √∫ltimos resultados (peso alto)
if w_e > 0.20:
    score += min(35, w_e * 100)
    manipulation_signals.append(f"Empates recentes elevados ({w_e:.0%})")

# sinal 2: dom√≠nio pesado de uma cor (com peso recente)
if w_c > 0.65:
    score += 25
    manipulation_signals.append(f"Dom√≠nio recente de {get_color_name('C')} ({w_c:.0%})")
if w_v > 0.65:
    score += 25
    manipulation_signals.append(f"Dom√≠nio recente de {get_color_name('V')} ({w_v:.0%})")

# sinal 3: streak atual longo
if cur_len >= 4 and cur_color != 'E':
    score += min(30, (cur_len - 3) * 8)
    manipulation_signals.append(f"Sequ√™ncia atual longa ({cur_len}x {get_color_name(cur_color)})")

# sinal 4: revers√µes detectadas
reversals = detect_reversal_patterns(results)
if reversals:
    score += min(30, len(reversals) * 8)
    manipulation_signals.append(f"Revers√µes detectadas ({len(reversals)})")

# sinal 5: √¢ncoras (empates usados estrategicamente)
anchors = detect_anchor_anchors(results)
if anchors:
    score += 15
    manipulation_signals.append(f"Empates como √¢ncoras ({len(anchors)})")

# sinal 6: baixa entropia (muito ordenado) ou entropia anormalmente alta (caos controlado)
# ent varia de 0 (determin√≠stico) at√© log2(3) ~= 1.585 (maior incerteza)
if ent < 0.8:
    score += 15
    manipulation_signals.append(f"Baixa entropia ({ent:.2f})")
elif ent > 1.4:
    score += 10
    manipulation_signals.append(f"Alta entropia ({ent:.2f})")

# sinal 7: padr√µes camuflados / repetidos
camu = sliding_window_patterns(results)
camu_count = sum(1 for p in camu if p['type'] in ('camuflado', '2x2'))
if camu_count:
    score += min(20, camu_count * 4)
    manipulation_signals.append(f"Padr√µes camuflados/2x2 ({camu_count})")

# sinal 8: altern√¢ncia quase perfeita (pode indicar manipula√ß√£o para embaralhar)
alternancias = sum(1 for i in range(1, len(results)) if results[i] != results[i-1])
alt_rate = alternancias / max(1, (len(results)-1))
if alt_rate > 0.85 and len(results) >= 8:
    score += 15
    manipulation_signals.append("Altern√¢ncia muito alta")

# normalizar score e converter em level 1-9
# score pode variar amplamente; mapeamos para 1..9
level = min(max(int(score // 10) + 1, 1), 9)

# garantimos que n√≠veis 8-9 s√≥ ocorram com sinais m√∫ltiplos fortes
strong = sum(1 for s in manipulation_signals if any(k in s for k in ['Sequ√™ncia', 'Dom√≠nio', 'Revers√µes', 'Empates', 'Baixa entropia']))
if level >= 8 and strong < 2:
    level = 7

return level, manipulation_signals

-------------------------

Predi√ß√£o multi-caminho com probabilidades

-------------------------

def predict_next(data: List[Dict], level: int) -> Dict: results = [d['result'] for d in data] n = len(results) if n == 0: return {'probs': {'C': 33, 'V': 33, 'E': 34}, 'top': None, 'confidence': 0}

# Pesos e sinais
weighted = weighted_counts(results, decay=0.88)
w_total = sum(weighted.values())
p_c = weighted['C'] / w_total
p_v = weighted['V'] / w_total
p_e = weighted['E'] / w_total

# baseline probs (convertendo para porcentagem)
base = {'C': p_c, 'V': p_v, 'E': p_e}

# ajustar por streak atual (preferir quebra quando streak longo)
_, (cur_color, cur_len) = get_streaks(results)
probs = base.copy()

# Se streak atual >=4 -> maior probabilidade de quebra; o break tende a ser o opp color ou empate
if cur_len >= 4 and cur_color in ('C', 'V'):
    opp = 'V' if cur_color == 'C' else 'C'
    probs[opp] += 0.30 * (cur_len - 3)  # aumenta chance do oposto
    probs['E'] += 0.10 * (cur_len - 3)
    probs[cur_color] *= max(0.2, 1 - 0.25 * (cur_len - 3))

# Se empates recentes altos, aumentar prob de empate
last10 = results[:10]
if last10.count('E') >= 2:
    probs['E'] += 0.25
    probs['C'] *= 0.8
    probs['V'] *= 0.8

# Se revers√µes detectadas recentemente, aumentar prob de repeats curtas
revs = detect_reversal_patterns(results)
if revs:
    # modera distribui√ß√£o para favorecer repeti√ß√µes curtas e quebras planejadas
    probs = {k: v * 1.0 for k, v in probs.items()}
    probs['E'] += 0.08 * len(revs)

# Normalizar e converter em porcentagem
total = sum(probs.values())
probs = {k: max(0.0, v/total) for k, v in probs.items()}
probs_pct = {k: round(v*100) for k, v in probs.items()}

# confian√ßa: combina√ß√£o do top prob e influ√™ncia do level (quanto maior o level, mais cautela)
top_color = max(probs, key=probs.get)
top_prob = probs[top_color]
# confian√ßa inicial baseada na diferen√ßa entre top e segundo
sorted_probs = sorted(probs.values(), reverse=True)
gap = sorted_probs[0] - sorted_probs[1] if len(sorted_probs) > 1 else sorted_probs[0]
confidence = int(min(95, max(30, top_prob * 100 + gap * 50 - level * 3)))

return {'probs': probs_pct, 'top': top_color, 'confidence': confidence}

-------------------------

Detecta brechas/risco

-------------------------

def detect_breach(data: List[Dict], level: int, manipulation_signals: List[str]) -> bool: results = [d['result'] for d in data] # Regra 1: n√≠vel alto -> consideramos brecha prov√°vel if level >= 7: return True # Regra 2: empates foram usados como √¢ncora e aparecem recentemente if any('Empates' in s or '√¢ncora' in s.lower() for s in manipulation_signals): return True # Regra 3: baixa entropia e repeti√ß√£o de padr√µes camuflados ent = shannon_entropy(results) camu = sliding_window_patterns(results) camu_sign = any(p['type'] in ('camuflado', '2x2') for p in camu) if ent < 0.7 and camu_sign: return True return False

-------------------------

An√°lise combinada

-------------------------

def analyze(): data = st.session_state.history if len(data) < 5: st.session_state.analysis = {} return

level, manipulation_signals = get_manipulation_level(data)
results = [d['result'] for d in data]
patterns = []
patterns.extend(detect_reversal_patterns(results))
patterns.extend(detect_anchor_anchors(results))
patterns.extend(sliding_window_patterns(results))

pred = predict_next(data, level)
breach = detect_breach(data, level, manipulation_signals)

recommendation = 'Aguardar'
# regra de recomenda√ß√£o: se top prob > 60% e sem brecha e level baixo-medio
if pred['top'] and pred['probs'][pred['top']] >= 60 and not breach and level <= 5:
    recommendation = 'Apostar'
# se top entre 50-60 -> s√≥ se level <=4
elif pred['top'] and pred['probs'][pred['top']] >= 50 and not breach and level <= 4:
    recommendation = 'Apostar'

st.session_state.analysis = {
    'manipulation_level': level,
    'manipulation_signals': manipulation_signals,
    'patterns': patterns,
    'prediction': pred,
    'breach_detected': breach,
    'recommendation': recommendation,
    'last_updated': time.time()
}

-------------------------

A√ß√µes do usu√°rio (inserir/reset)

-------------------------

def add_result(result: str): # inserimos no √≠ndice 0 para manter formato do cassino (mais recente √† esquerda) st.session_state.history.insert(0, {'result': result, 'timestamp': time.time()}) # limitamos hist√≥rico para 90 resultados (9 cols x 10 linhas) if len(st.session_state.history) > 90: st.session_state.history = st.session_state.history[:90] analyze()

def reset(): st.session_state.history = [] st.session_state.analysis = {}

-------------------------

Interface Streamlit

-------------------------

st.title("üéØ Football Studio - IA Avan√ßada (v2)") col1, col2 = st.columns([2, 1])

with col1: st.subheader("üéÆ Inserir Resultado (formato cassino: mais recente √† ESQUERDA)") c1, c2, c3 = st.columns(3) with c1: st.button("üî¥ Vermelho (C)", on_click=add_result, args=("C",)) with c2: st.button("üîµ Azul (V)", on_click=add_result, args=("V",)) with c3: st.button("üü° Empate (E)", on_click=add_result, args=("E",)) st.button("üîÑ Resetar Hist√≥rico", on_click=reset)

# Exibir hist√≥rico: mais recente √† esquerda, 9 por linha
st.subheader("üìä Hist√≥rico (mais recente √† esquerda)")
if st.session_state.history:
    hist = st.session_state.history  # j√° tem ordem desejada
    # mostramos at√© 10 linhas de 9 resultados
    rows = [hist[i:i+9] for i in range(0, min(len(hist), 90), 9)]
    for row in rows:
        st.markdown("**" + " ".join(emoji_map[d['result']] for d in row) + "**")
    st.write(f"Total registrado: {len(hist)}")

    # Estat√≠sticas e visualiza√ß√£o r√°pida
    st.subheader("üìà Estat√≠sticas R√°pidas")
    total = len(hist)
    freq = Counter([d['result'] for d in hist])
    st.write(f"üî¢ Distribui√ß√£o (mais recente ponderado): C={freq['C']} V={freq['V']} E={freq['E']}")
else:
    st.info("Nenhum resultado inserido ainda.")

with col2: st.subheader("üìà An√°lise em Tempo Real (avan√ßada)") analysis = st.session_state.analysis if analysis: st.write(f"üî¢ N√≠vel de Manipula√ß√£o: {analysis['manipulation_level']}/9") if analysis['manipulation_signals']: st.write("‚ö†Ô∏è Sinais de Manipula√ß√£o Detectados:") for s in analysis['manipulation_signals']: st.write(f"- {s}")

# Predi√ß√£o multi-caminho
    pred = analysis['prediction']
    probs = pred['probs']
    st.write("üéØ Previs√£o multi-caminho:")
    st.write(f"- {emoji_map['C']} Vermelho: {probs['C']}%")
    st.write(f"- {emoji_map['V']} Azul: {probs['V']}%")
    st.write(f"- {emoji_map['E']} Empate: {probs['E']}%")
    st.write(f"üí° Top: {emoji_map.get(pred['top'], '...')}  Confian√ßa: {pred['confidence']}%")

    st.write("üîé Padr√µes detectados:")
    shown = set()
    for p in analysis['patterns']:
        desc = p.get('description', str(p))
        if desc not in shown:
            st.write(f"- {desc}")
            shown.add(desc)

    st.write(f"‚ö†Ô∏è Brecha detectada: {'Sim' if analysis['breach_detected'] else 'N√£o'}")
    st.write(f"‚úÖ Recomenda√ß√£o: {analysis['recommendation']}")
else:
    st.write("Aguardando mais dados para an√°lise (m√≠nimo 5 resultados)...")

Ao carregar a p√°gina, podemos analisar automaticamente se j√° houver dados

if st.session_state.history and not st.session_state.analysis: analyze()

Rodap√© com dicas r√°pidas

st.markdown("---") st.caption("Dicas: o algoritmo d√° mais peso √†s jogadas recentes, detecta revers√µes e empates-√¢ncora, e gera probabilidades para cada cor. N√≠veis 7-9 indicam sinais fortes de manipula√ß√£o ‚Äî agir com cautela.")

